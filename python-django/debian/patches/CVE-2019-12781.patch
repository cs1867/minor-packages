From ec6b5d655896e3039308ea0511210d577ecfc78d Mon Sep 17 00:00:00 2001
From: Mariusz Felisiak <felisiak.mariusz@gmail.com>
Date: Thu, 20 Jun 2019 10:45:38 +0200
Subject: [PATCH] Fixed CVE-2019-12781 -- Made HttpRequest always trust
 SECURE_PROXY_SSL_HEADER if set.

An HTTP request would not be redirected to HTTPS when the
SECURE_PROXY_SSL_HEADER and SECURE_SSL_REDIRECT settings were used if
the proxy connected to Django via HTTPS.

HttpRequest.scheme will now always trust the SECURE_PROXY_SSL_HEADER if
set, rather than falling back to the request scheme when the
SECURE_PROXY_SSL_HEADER did not have the secure value.

Thanks to Gavin Wahl for the report and initial patch suggestion, and
Shai Berger for review.
---
 django/http/request.py        |  7 ++++---
 docs/ref/settings.txt         | 11 +++++++----
 docs/releases/1.11.22.txt     | 27 +++++++++++++++++++++++++++
 docs/releases/index.txt       |  1 +
 tests/settings_tests/tests.py | 12 ++++++++++++
 5 files changed, 51 insertions(+), 7 deletions(-)
 create mode 100644 docs/releases/1.11.22.txt

diff --git a/django/http/request.py b/django/http/request.py
index 9ffcd23fbd..b573cdb180 100644
--- a/django/http/request.py
+++ b/django/http/request.py
@@ -199,13 +199,14 @@ class HttpRequest(object):
     def scheme(self):
         if settings.SECURE_PROXY_SSL_HEADER:
             try:
-                header, value = settings.SECURE_PROXY_SSL_HEADER
+                header, secure_value = settings.SECURE_PROXY_SSL_HEADER
             except ValueError:
                 raise ImproperlyConfigured(
                     'The SECURE_PROXY_SSL_HEADER setting must be a tuple containing two values.'
                 )
-            if self.META.get(header) == value:
-                return 'https'
+            header_value = self.META.get(header)
+            if header_value is not None:
+                return 'https' if header_value == secure_value else 'http'
         return self._get_scheme()
 
     def is_secure(self):
diff --git a/docs/ref/settings.txt b/docs/ref/settings.txt
index 0e856a12f9..6b84d34f77 100644
--- a/docs/ref/settings.txt
+++ b/docs/ref/settings.txt
@@ -2189,10 +2189,13 @@ whether a request is secure by looking at whether the requested URL uses
 "https://". This is important for Django's CSRF protection, and may be used
 by your own code or third-party apps.
 
-If your Django app is behind a proxy, though, the proxy may be "swallowing" the
-fact that a request is HTTPS, using a non-HTTPS connection between the proxy
-and Django. In this case, ``is_secure()`` would always return ``False`` -- even
-for requests that were made via HTTPS by the end user.
+If your Django app is behind a proxy, though, the proxy may be "swallowing"
+whether the original request uses HTTPS or not. If there is a non-HTTPS
+connection between the proxy and Django then ``is_secure()`` would always
+return ``False`` -- even for requests that were made via HTTPS by the end user.
+In contrast, if there is an HTTPS connection between the proxy and Django then
+``is_secure()`` would always return ``True`` -- even for requests that were
+made originally via HTTP.
 
 In this situation, you'll want to configure your proxy to set a custom HTTP
 header that tells Django whether the request came in via HTTPS, and you'll want
diff --git a/docs/releases/1.11.22.txt b/docs/releases/1.11.22.txt
new file mode 100644
#index 0000000000..58ea68146e
#--- /dev/null
#+++ b/docs/releases/1.11.22.txt
#@@ -0,0 +1,27 @@
#+============================
#+Django 1.11.22 release notes
#+============================
#+
#+*July 1, 2019*
#+
#+Django 1.11.22 fixes a security issue in 1.11.21.
#+
#+CVE-2019-12781: Incorrect HTTP detection with reverse-proxy connecting via HTTPS
#+--------------------------------------------------------------------------------
#+
#+When deployed behind a reverse-proxy connecting to Django via HTTPS,
#+:attr:`django.http.HttpRequest.scheme` would incorrectly detect client
#+requests made via HTTP as using HTTPS. This entails incorrect results for
#+:meth:`~django.http.HttpRequest.is_secure`, and
#+:meth:`~django.http.HttpRequest.build_absolute_uri`, and that HTTP
#+requests would not be redirected to HTTPS in accordance with
#+:setting:`SECURE_SSL_REDIRECT`.
#+
#+``HttpRequest.scheme`` now respects :setting:`SECURE_PROXY_SSL_HEADER`, if it
#+is configured, and the appropriate header is set on the request, for both HTTP
#+and HTTPS requests.
#+
#+If you deploy Django behind a reverse-proxy that forwards HTTP requests, and
#+that connects to Django via HTTPS, be sure to verify that your application
#+correctly handles code paths relying on ``scheme``, ``is_secure()``,
#+``build_absolute_uri()``, and ``SECURE_SSL_REDIRECT``.
#diff --git a/docs/releases/index.txt b/docs/releases/index.txt
#index c2e8503102..e00804d651 100644
#--- a/docs/releases/index.txt
#+++ b/docs/releases/index.txt
#@@ -26,6 +26,7 @@ versions of the documentation contain the release notes for any later releases.
# .. toctree::
#    :maxdepth: 1
# 
#+   1.11.22
#    1.11.21
#    1.11.20
#    1.11.19
diff --git a/tests/settings_tests/tests.py b/tests/settings_tests/tests.py
index bf015affc2..012264dc34 100644
--- a/tests/settings_tests/tests.py
+++ b/tests/settings_tests/tests.py
@@ -334,6 +334,18 @@ class SecureProxySslHeaderTest(SimpleTestCase):
         req.META['HTTP_X_FORWARDED_PROTOCOL'] = 'https'
         self.assertIs(req.is_secure(), True)
 
+    @override_settings(SECURE_PROXY_SSL_HEADER=('HTTP_X_FORWARDED_PROTOCOL', 'https'))
+    def test_xheader_preferred_to_underlying_request(self):
+        class ProxyRequest(HttpRequest):
+            def _get_scheme(self):
+                """Proxy always connecting via HTTPS"""
+                return 'https'
+
+        # Client connects via HTTP.
+        req = ProxyRequest()
+        req.META['HTTP_X_FORWARDED_PROTOCOL'] = 'http'
+        self.assertIs(req.is_secure(), False)
+
 
 class IsOverriddenTest(SimpleTestCase):
     def test_configure(self):
-- 
2.17.1


